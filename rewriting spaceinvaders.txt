// Set up all interrupt handling
setUp:

		mov r0, #handleKeyPress
		str r0, .KeyboardISR 
		mov r0,#1
		strb r0, .KeyboardMask
		
		mov r1, #handleClockInterrupt
		str r1,.ClockISR
		mov r1,#0x11		//100ms 
		strb r1,.ClockInterruptFrequency
		

//Enable all interrupts
      mov r0,#1
      strb r0,.InterruptRegister
	  mov r1,#1
	  strb r1,.InterruptRegister


Main:
	
	bl moveInvaders
		b Main				//infinite loop to test if keyboard presses work 
	
halt

handleClockInterrupt:
	push {lr,r9,r10}
	
		ldr r9,interruptCounter
		add r9,r9,#1
		str r9,interruptCounter
		ldr r10,shipMove
		
		checkMoveShip:
		cmp r9,#8
		bne endClockInt
		
		cmp r10,#1
		bne endClockInt
		bl moveShip
		
		
		resetIntCount:
		mov r9,#0
	
	endClockInt:
		cmp r9,#8
		beq resetIntCount
			
		bl handleLasers	
		str r9,interruptCounter
	pop {lr,r9,r10}
	RFE
	

//call this from interrupt
handleKeyPress:			
	push {lr,r5,r10,r11,r12}
	ldr r12,.LastKey
	mov r10,#1
	
	cmp r12,#65		//A
	bne checkForD	
	mov r11,#0				//r11 is the direction of the ship
	str r11,shipDirection
	str r10,shipMove
	//bl moveShip
		
	checkForD:
	cmp r12,#68		//D
	bne checkForS	
	mov r11,#2
	str r11,shipDirection	
	str r10,shipMove
	//bl moveShip
	
	checkForS:
	cmp r12,#83		//S
	bne checkForSpace
	mov r11,#1
	str r11,shipDirection
	str r10,shipMove
		
	checkForSpace:
	cmp r12,#32
	bne exit
	mov r5,#1					//r5 is changed but isnt restored, r12 would be fine
	str r5,existingLaser
	bl handleLasers
	
	exit:
	pop {lr,r5,r10,r11,r12}
	RFE					//RFE = return from exception


moveShip:
	push {lr,r0-r5,r10,r11}
	ldr r11,shipDirection		//for the ship direction 0 is left (1 will be still) and 2 is right)
    ldr r0,shipX
    ldr r1,shipY
	bl clearShip
	ldr r4,screenLeftEdge
	ldr r5,screenRightEdge
	

	
	cmp r11,#0					//checking what direction to move the ship in
	beq moveLeft
	cmp r11,#1
	beq stayStill
	cmp r11,#2
	beq moveRight
	b msEnd
	
	moveLeft:
	cmp r0,r4
	beq msEnd			//checking if the ship is at the edge of the screen
	
	sub r0,r0,#1
	b msEnd
	
	moveRight:
	cmp r0,r5
	beq msEnd			//checking if the ship is at the edge of the screen
	
	add r0,r0,#1

	b msEnd
	
	stayStill:
	b msEnd
	
	msEnd:
	bl drawShip
	str r0,shipX
	str r11,shipDirection
	mov r10,#0
	//str r10,shipMove
	pop {lr,r0-r5,r10,r11}
	RET
	
//given x in r0 and y in r1 draws the ship at that location	
drawShip:					
	push {lr,r0-r3}
	

	
		mov r3,#10			//blue colour | will change back to green if wanted
		bl drawFromXY
		
		add r0,r0,#1
		bl drawFromXY
		
		sub r0,r0,#2
		bl drawFromXY
		
		add r0,r0,#1
		bl drawFromXY
		
		sub r1,r1,#1		
		bl drawFromXY
		add r1,r1,#1
	
	pop {lr,r0-r3}
	RET

//given x in r0 and y in r1 draws the ship at that location	
clearShip:					
	push {lr,r0-r3}
	

		mov r3,#0			//white, back colour
		bl drawFromXY
		
		add r0,r0,#1
		bl drawFromXY
		
		sub r0,r0,#2
		bl drawFromXY
		
		add r0,r0,#1
		bl drawFromXY
		
		sub r1,r1,#1		
		bl drawFromXY
		add r1,r1,#1
		
	
	pop {lr,r0-r3}
	RET
	
//given x in r0 and y in r1 draws a white pixel at that location (white is the background colour)	
clearpixel:					
	push {lr,r0-r3}
	
		mov r3,#0			
		bl drawFromXY
	
	pop {lr,r0-r3}
	RET
	
//clearing a row of invaders. basically the same as drawRowInvader but draws them in white.
clearRow:
	push {lr}
	 		
		loopRowClear:
			bl clearpixel			
			add r0,r0,#2
			sub r10,r10,#1
			cmp r10,#0
			bne loopRowClear
		ldr r0,baseClearingX
		ldr r10,clearSpaceWidth
	pop {lr}
	RET	
//Clears a grid (of invaders) . Basically drawing a white coloured grid of invaders	
clearGrid:

	push {lr,r0,r1,r10,r11}
		
		ldr r0,baseClearingX
		ldr r1,baseClearingY
		ldr r10,clearSpaceWidth
		ldr r11,clearSpaceHeight
		
		loopColClear:
		
			bl clearRow
			add r1,r1,#2
			sub r11,r11,#1
			cmp r11,#0			
			bne loopColClear
			
	pop {lr,r0,r1,r10,r11}
	RET

//given x in r0 and y in r1 draws a space invader at that location
drawSingleInvader:					
	push {lr,r0-r3}
	
		mov r3,#55			//green colour
		bl drawFromXY
		

	
	pop {lr,r0-r3}
	RET
	
//given x in r0 and y in r1 (the starting position) will draw a row of space invaders given a width in invaderRowWidth
drawRowInvader:				
	push {lr}
	 		
		loopRow:
			bl drawSingleInvader			
			add r0,r0,#2
			sub r10,r10,#1
			cmp r10,#0
			bne loopRow
		ldr r0,baseInvaderX
		ldr r10,invaderRowWidth
	pop {lr}
	RET

//takes in starting x in baseInvaderX y in baseInvaderY, rows in invaderRowWidth, cols in invaderColLength (keeps direction in r10) 
drawGridOfInvaders:			
	push {lr,r0,r1,r10,r11}
		
		ldr r0,baseInvaderX
		ldr r1,baseInvaderY
		ldr r10,invaderRowWidth
		ldr r11,invaderColLength
		
		loopCol:
		
			bl drawRowInvader
			add r1,r1,#2
			sub r11,r11,#1
			cmp r11,#0			
			bne loopCol
			
	pop {lr,r0,r1,r10,r11}
	RET
	
moveInvaders:
	push {lr,r0,r4,r5,r6,r7,r10,r11}	
	ldr r10,invaderRowWidth
	ldr r11,invaderColLength
	ldr r4,screenLeftEdge
	ldr r5,screenRightEdge
	mov r7,#8

	lsl r10,r10,#1
	add r10,r10,#8
	sub r5,r5,r10						//changing the edge of the screen so that the invaders dont go off it
	add r11,r11,#8
	ldr r6,invaderDirection
	
	bl clearGrid
	
	ldr r0,baseInvaderX
	ldr r1,baseInvaderY

	cmp r0,r5
	bgt moveIDown
	cmp r0,r4
	blt moveIDown
	
	checkIDR:
		cmp r6,#2
		bne checkIDL
		b moveIRight

		checkIDL:
			cmp r6,#0
			bne moveIEnd
			b moveILeft
			
		
	moveIRight:
		add r0,r0,r7				//moves invaders 5 spaces to the right
		b moveIEnd
		
	moveILeft:
		sub r0,r0,r7				//moves invaders 5 spaces to the left
		b moveIEnd

	moveIDown:
		add r1,r1,r7
		b changeID	

	changeID:
		cmp r6,#0
		bne changeIDR
		mov r6,#2
		b moveIRight
		
		changeIDR:
			cmp r6,#2
			bne moveIEnd
			mov r6,#0
			b moveILeft
			
			
	
	moveIEnd:
	str r6,invaderDirection	
	str r0,baseInvaderX
	str r0,baseClearingX	
	str r1,baseInvaderY
	str r1,baseClearingY
	bl drawGridOfInvaders
	pop {lr,r0,r4,r5,r6,r7,r10,r11}
	RET

	
//when space pressed, then it shoots a laser starting above the ship and will keep going to the top then a new laser will be able to be fired.

drawLaser:					
	push {lr,r0-r3}
	
		mov r3,#120			//red colour
		bl drawFromXY
	
	pop {lr,r0-r3}
	RET	
	
handleLasers:
	push {lr,r0,r1,r5}
	
		ldr r5,existingLaser

		
		
		checkForLaser:
			cmp r5,#0
			beq hLExit
			
			cmp r5,#1
			beq initialFire
			
			cmp r5,#2
			beq moveLaser
			
		b hLExit
				
		initialFire:
			ldr r0,shipX
			ldr r1,shipY

			str r0,laserX
			str r1,laserY

			sub r1,r1,#1
			bl drawLaser
			
			mov r5,#2
			
		b hLExit
		
		
		moveLaser:
			ldr r0,laserX
			ldr r1,laserY
			
			bl clearpixel
			sub r1,r1,#1
			bl drawLaser
			
			cmp r1,#0
			bne hLExit
			mov r5,#0

	hLExit:
	str r5,existingLaser
	str r0,laserX
	str r1,laserY		
	pop {lr,r0,r1,r5}
	RET

//given x in r0, y in r1 returns screen pos from r2 and then calls editPixel at that location on the screen	
drawFromXY:			
	push {lr}
	
	mov r2,#0
	
	lsl r2,r1,#7	//changed from multiplying by adding to using LSL to multiply the y value by 128
	add r2,r2,r0	//this now runs much faster
	bl editPixel
	
	
	pop {lr}
	RET

editPixel:			//r3 colour
	push {lr,r12}
	mov r12,#.PixelScreen
	strb r3,[r2+r12]
	pop {lr,r12}
	RET
	
	
halt


//storing these in main memory---KEEP IT AT THE BOTTOM
shipX:
	.word 4
	
shipY:
	.word 90
	
shipDirection:
	.word 1

shipMove:
	.word 0

	
laserX:
	.word 1
	
laserY:
	.word 1
	
existingLaser:
	.word 1
	
	
baseInvaderX:
	.word 8
		
baseInvaderY:
	.word 8
	
invaderRowWidth:
	.word 11
	
invaderColLength:
	.word 5	
	
invaderDirection:
	.word 2
	

baseClearingX:
	.word 8
		
baseClearingY:
	.word 8
	
clearSpaceWidth:
	.word 11
	
clearSpaceHeight:
	.word 5
	
	
screenLeftEdge:
	.word 0
	
screenRightEdge:
	.word 127
	
interruptCounter:
	.word 0