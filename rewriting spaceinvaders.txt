setUp:
// Set up Clockinterrupt handling
		mov r0, #handleKeyPress
		str r0, .KeyboardISR 
		mov r0,#1
		strb r0, .KeyboardMask


//Enable all interrupts
      mov r0,#1
      strb r0,.InterruptRegister





Main:
		b Main
	
halt




handleKeyPress:			//call this from interupt
	push {lr,r3,r4}
	
	ldr r4,.LastKey
	
	
	cmp r4,#65		//A
	bne checkForD
	
	mov r3,#0
	bl moveShip
	
	checkForD:
	cmp r4,#68		//D
	bne checkForSpace
	
	mov r3,#2
	bl moveShip
	
	
	checkForSpace:
	cmp r4,#32
	bne exit
	
	exit:
	pop {lr,r3,r4}
	RFE					//RFE = return from exception



moveShip:
	push {lr,r0-r3}
	ldr r3,shipDirection
    ldr r0,shipX
    ldr r1,shipY
    bl clearPixel
	
	cmp r3,0 			//0 = left
	bne goRight
	beq goLeft
	
	goLeft:
	
	goRight:
	
	
	
	pop {lr,r0-r3}
	RET
	
moveShipR:
	push {lr}
	
	pop {lr}
	RET

drawGridOfInvaders:			//takes in starting x in r0 y in r1, rows in r11, cols in r12 (keeps direction in r10
	push {lr,r5}
	
	str r0,baseInvaderX
	str r1,baseInvaderY
	
		loopRow:
			cmp r11,#0
			beq exitGrid
			
			
		
	exitGrid:
	pop {lr,r5}
	RET



drawFromXY:			//takes in X from r0 and Y from r1 and returns the screen pos from r2

	push {lr}		
	mov r2,#0
    loopY:				//calculating y
	    add r2,r2,#32		//32 is the screen width
	    sub r1,r1,#1
	    cmp r1,#0
	    bgt loopY
	    add r2,r2,r0		//adding x value to the (y * 32) value
		bl drawPixel 
	    pop {lr}
	    RET	
	

drawPixel:
	push {lr}
	strb r3,[r2+.PixelScreen]
	pop {lr}
	RET
	
	
halt


//storing these in main memory---KEEP IT AT THE BOTTOM
shipX:
	.word 4
	
shipY:
	.word 20
	
shipDirection:
	.word 1

laserX:
	.word 1
	
laserY:
	.word 1
	
baseInvaderX:
	.word 1
		
baseInvaderY:
	.word 1
	
invaderDirection:
	.word 1