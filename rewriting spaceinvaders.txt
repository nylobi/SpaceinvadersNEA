// Set up all interrupt handling
setUp:

		mov r0, #handleKeyPress
		str r0, .KeyboardISR 
		mov r0,#1
		strb r0, .KeyboardMask
		
		mov r1, #handleClockInterrupt
		str r1,.ClockISR
		mov r1,#0x05		//50ms 
		strb r1,.ClockInterruptFrequency
		

//Enable all interrupts
      //mov r0,#1
      //strb r0,.InterruptRegister
	  //mov r1,#1
	  //strb r1,.InterruptRegister

	//bl moveInvaders
	//mov r0,r0				//no op , forces the screen to update
		//b Main				//infinite loop to test if keyboard presses work 
Main:
	
	bl drawRowOf23Invader
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow
	halt
	bl moveRow

halt

handleClockInterrupt:
	push {lr,r9,r10}
	
		ldr r9,interruptCounter
		add r9,r9,#1
		str r9,interruptCounter
		ldr r10,shipMove
		
		checkMoveShip:
		cmp r9,#8
		bne endClockInt
		
		cmp r10,#1
		bne endClockInt
		bl moveShip
		
		
		resetIntCount:
		mov r9,#0
	
	endClockInt:
		cmp r9,#8
		beq resetIntCount
			
		bl handleLasers	
		str r9,interruptCounter
	pop {lr,r9,r10}
	RFE
	

//call this from interrupt
handleKeyPress:			
	push {lr,r5,r10,r11,r12}
	ldr r12,.LastKey
	mov r10,#1
	
	cmp r12,#65		//A
	bne checkForD	
	mov r11,#0				//r11 is the direction of the ship
	str r11,shipDirection
	str r10,shipMove
	//bl moveShip
		
	checkForD:
	cmp r12,#68		//D
	bne checkForS	
	mov r11,#2
	str r11,shipDirection	
	str r10,shipMove
	//bl moveShip
	
	checkForS:
	cmp r12,#83		//S
	bne checkForSpace
	mov r11,#1
	str r11,shipDirection
	str r10,shipMove
		
	checkForSpace:
	cmp r12,#32
	bne exit
	mov r5,#1					//r5 is changed but isnt restored, r12 would be fine
	str r5,existingLaser
	bl handleLasers
	
	exit:
	pop {lr,r5,r10,r11,r12}
	RFE					//RFE = return from exception


moveShip:
	push {lr,r0-r5,r10,r11}
	ldr r11,shipDirection		//for the ship direction 0 is left (1 will be still) and 2 is right)
    ldr r0,shipX
    ldr r1,shipY
	bl clearShip
	ldr r4,screenLeftEdge
	ldr r5,screenRightEdge
		
	cmp r11,#0					//checking what direction to move the ship in
	beq moveLeft
	cmp r11,#1
	beq stayStill
	cmp r11,#2
	beq moveRight
	b msEnd
	
	moveLeft:
	cmp r0,r4
	beq msEnd			//checking if the ship is at the edge of the screen
	
	sub r0,r0,#1
	b msEnd
	
	moveRight:
	cmp r0,r5
	beq msEnd			//checking if the ship is at the edge of the screen
	
	add r0,r0,#1

	b msEnd
	
	stayStill:
	b msEnd
	
	msEnd:
	bl drawShip
	str r0,shipX
	str r11,shipDirection
	mov r10,#0
	//str r10,shipMove
	pop {lr,r0-r5,r10,r11}
	RET
	
//given x in r0 and y in r1 draws the ship at that location	
drawShip:					
	push {lr,r0-r3}
	
		mov r3,#10			//blue colour | will change back to green if wanted
		bl drawFromXY
		
		add r0,r0,#1
		bl drawFromXY
		sub r0,r0,#2
		bl drawFromXY
		add r0,r0,#1
		
		sub r1,r1,#1
		bl drawFromXY
	
	pop {lr,r0-r3}
	RET

//given x in r0 and y in r1 draws the ship at that location	
clearShip:					
	push {lr,r0-r3}

		mov r3,#0			//white, back colour
		bl drawFromXY
		
		add r0,r0,#1
		bl drawFromXY
		sub r0,r0,#2
		bl drawFromXY
		add r0,r0,#1
		
		sub r1,r1,#1
		bl drawFromXY	
	
	pop {lr,r0-r3}
	RET
	
//given x in r0 and y in r1 draws a white pixel at that location (white is the background colour)	
clearpixel:					
	push {lr,r0-r3}
	
		mov r3,#0			
		bl drawFromXY
	
	pop {lr,r0-r3}
	RET
	

//given a colour in r3 draws a space invader at that location specified in main memory
editR23Invader:					
	push {lr,r0-r2,r8-r12}
	
mov r11,#invaderRow23ArmsUp

        mov r12,#0    //row
		mov r9,#1			//the mask
			
		ldr r0,baseR2InvaderX
		ldr r1,baseR2InvaderY
					
		loopDSI:
			ldrb r10,[r11 + r12]		//only gets 8 bits 
			and r8,r10,r9
			cmp r8,#0
			beq next
			// if it is equal then draw the pixel of the right colour
			bl drawFromXY
				//draw the next bit in the row
				//LSL r9 by 1, once r1 it is over 256 then exit the loop and increment r12 by 1 and then keep going until r12 is 7/8			
				next:
					lsl r9,r9,#1
					add r0,r0,#1
						cmp r9,#256
						beq next2
						b loopDSI					
						//move to the next row
						next2:					
							mov r9,#1
							add r12,r12,#1
							add r1,r1,#1
							ldr r0,baseR2InvaderX
							cmp r12,#8
							beq exitDSI												
			b loopDSI			
		exitDSI:
		ldr r0,storedR2InvaderX
		str r0,baseR2InvaderX
		mov r0,r0		//no op

	pop {lr,r0-r2,r8-r12}
	RET
	
//given x in r0 and y in r1 (the starting position) will draw a row of space invaders given a width in invaderRowWidth
drawRowOf23Invader:				
	push {lr,r3,r10}
		ldr r0,baseR2InvaderX
		ldr r10,invaderRowWidth
		
		loopRow:
			mov r3,#55
			bl editR23Invader
		
			add r0,r0,#12			//spacing between invaders
			sub r10,r10,#1
			str r0,baseR2InvaderX
			cmp r10,#0
			bne loopRow
		ldr r0,baseR2InvaderX
		ldr r10,invaderRowWidth
	pop {lr,r3,r10}
	RET
	
//given x in r0 and y in r1 (the starting position) will draw a row of space invaders given a width in invaderRowWidth
clearRowOf23Invader:				
	push {lr,r3,r10}
		ldr r0,storedR2InvaderX
		str r0,baseR2InvaderX
		ldr r10,invaderRowWidth
		
		loopClearRow:	
			mov r3,#0
			bl editR23Invader
		
			add r0,r0,#12			//spacing between invaders
			sub r10,r10,#1
			str r0,baseR2InvaderX
			cmp r10,#0
			bne loopClearRow
			
		ldr r0,baseR2InvaderX
		ldr r10,invaderRowWidth
	pop {lr,r3,r10}
	RET


moveRow:
		push {lr,r0,r1,r4-r7,r10}
		
		mov r6,#0
		add r6,r6,#1
		
		ldr r7,invaderDirection
		ldr r10,invaderRowWidth
		ldr r4,screenLeftEdge
		ldr r5,screenRightEdge
		
		bl clearRowOf23Invader
		
		ldr r0,storedR2InvaderX
		ldr r1,baseR2InvaderY
		
		checkIRightEdge:
			cmp r0,#24
			bne checkILeftEdge
			mov r7,#1
		
		checkILeftEdge:
			cmp r0,#0
			bne checkMRRight
			mov r7,#1
		
		checkMRRight:
			cmp r7,#2
			beq moveRowRight
		
		checkMRLeft:
			cmp r7,#0
			beq moveRowLeft
			
		checkMRDown:
			cmp r7,#1
			beq moveRowDown
		
		
		moveRowDown:
			add r1,r1,#2
			str r1,baseR2InvaderY
			ldr r0,storedR2InvaderX
			str r0,baseR2InvaderX
			bl drawRowOf23Invader
			
			cmp r0,#132
			mov r7,#0
			str r7,invaderDirection
			bl clearRowOf23Invader
			mov r0,#24
			b moveRowLeft
		
		moveRowRight:
			add r0,r0,#2
			str r0,baseR2InvaderX
			str r0,storedR2InvaderX
			bl drawRowOf23Invader
			b endMoveRow
			
		moveRowLeft:
			sub r0,r0,#2
			str r0,baseR2InvaderX
			str r0,storedR2InvaderX
			bl drawRowOf23Invader
			b endMoveRow
				
		endMoveRow:
		
	
		pop {lr,r0,r1,r4-r7,r10}
		RET
	
//when space pressed, then it shoots a laser starting above the ship and will keep going to the top then a new laser will be able to be fired.

drawLaser:					
	push {lr,r0-r3}
	
		mov r3,#120			//red colour
		bl drawFromXY
	
	pop {lr,r0-r3}
	RET	
	
handleLasers:
	push {lr,r0,r1,r5}
	
		ldr r5,existingLaser

		
		checkForLaser:
			cmp r5,#0
			beq hLExit
			
			cmp r5,#1
			beq initialFire
			
			cmp r5,#2
			beq moveLaser
			
		b hLExit
				
		initialFire:
			ldr r0,shipX
			ldr r1,shipY

			str r0,laserX
			str r1,laserY

			sub r1,r1,#1
			bl drawLaser
			
			mov r5,#2
			
		b hLExit
		
		moveLaser:
			ldr r0,laserX
			ldr r1,laserY
			
			bl clearpixel
			sub r1,r1,#1
			bl drawLaser
			
			cmp r1,#0
			bne hLExit
			mov r5,#0

	hLExit:
	str r5,existingLaser
	str r0,laserX
	str r1,laserY		
	pop {lr,r0,r1,r5}
	RET

//given x in r0, y in r1 returns screen pos from r2 and then calls editPixel at that location on the screen	
drawFromXY:			
	push {lr,r2}
	
	mov r2,#0
	
	lsl r2,r1,#7	//changed from multiplying by adding to using LSL to multiply the y value by 128
	add r2,r2,r0	//this now runs much faster
	bl editPixel
	
	pop {lr,r2}
	RET

editPixel:			//r3 colour
	push {lr,r12}
	mov r12,#.PixelScreen
	strb r3,[r2+r12]
	pop {lr,r12}
	RET
	
halt

//storing these in main memory---KEEP IT AT THE BOTTOM
shipX:
	.word 4
	
shipY:
	.word 90
	
shipDirection:
	.word 1

shipMove:
	.word 0


laserX:
	.word 1
	
laserY:
	.word 1
	
existingLaser:
	.word 1
	
	
baseR2InvaderX:
	.word 8
		
storedR2InvaderX:
	.word 8
	
baseR2InvaderY:
	.word 8
	
invaderRowWidth:
	.word 9
	
invaderColLength:
	.word 2
	
invaderDirection:
	.word 2


	
	
screenLeftEdge:
	.word 0
	
screenRightEdge:
	.word 127
	
interruptCounter:
	.word 0
	
invaderRow23ArmsUp:
	.byte 0b01000010
	.byte 0b00100100
    .byte 0b10111101
	.byte 0b11011011
	.byte 0b11111111
	.byte 0b01000010
	.byte 0b10000001
	.byte 0b00000000
	
invader23ArmsDown:
	.byte 0b01000010
    .byte 0b00100100
	.byte 0b00111100
	.byte 0b01011010
	.byte 0b11111111
	.byte 0b11000011
	.byte 0b10100101
	.byte 0b00000000