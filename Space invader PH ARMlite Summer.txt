defineRegisters:
	mov r0,#0           //variable x
	mov r1,#0           //variable y
	mov r2,#0           //xy pos
	
	mov r6,#11          //Space invader cols
	mov r7,#5         //Space invader rows
	mov r8,#1           //space invader direction (0 for left, 1 for right)
	mov r9,#1           //space invader x and y
	mov r10,#3   
	       
	mov r11,#1          // r11 and r12 storing x and y coordinates of spaceship
	mov r12,#20
	

main:

    inp r2,4
    cmp r2,#32 // SPACE
    // if space has been pressed, shoot a laser


    bl drawInvaderGrid
    bl drawShip
    	
infLoop:
    bl moveShip
    bl moveInvaders
    bl infLoop
	halt
	
	
drawInvaderGrid:                   //give x in r9, y in r10, cols in r3, rows in r4 draws a grid with a space of one
    push {lr,r0-r5,r11}                 //when y > 0, grid ok but else grid is broken.  x + col shouldnt >= 17 or bad
    
    // get properties of invaders
    mov r0,r9
    mov r1,r10
    mov r3,r6
    mov r4,r7
    // including cols, rows
       
    loopRow:
        cmp r4,#0
        beq exit
        
        bl calculateXYLocation 
        sub r4,r4,#1
        add r1,r1,#2
                
        mov r5,r3
        loopColumn:
            
            cmp r5,#0
            beq loopRow
            mov r11,#55
            strb r11,[r2+3328]
            sub r5,r5,#1
            add r2,r2,#2
            bl loopColumn
        
        exit:
        pop {lr,r0-r5,r11}
        mov pc, lr
	

    

calculateXYLocation:		//given a value for x in r0, y in r1, returns screen position in r2
	push {lr,r0-r1}		//restore all value EXCEPT THE RETURN VALUE
	mov r2,#0
    loopY:				//calculating y
	    add r2,r2,#32
	    sub r1,r1,#1
	    cmp r1,#0
	    bgt loopY
	    add r2,r2,r0		//calculating left
	    pop {lr,r0-r1}
	    mov pc, lr		//return from a subroutine

paintScreen:			//changes all squares to the colour defined in r0
	push {lr,r1}
				        //colour in all the squares white by starting at square 0, and increasing the counter by one each time the loop finishes.
	mov r1,#767
	mov r0,#144
    loopPaint:
	    strb r0,[r1+3328]
	    sub r1,r1,#1
	    cmp r1,#0
	    bgt loopPaint	
	    strb r0,[r1+3328]
	    pop {lr,r1}
	    mov pc, lr
	
clearPixel:            //given value for x in r0, y in r1, colours in that square white(background colour) in main memory (#144)
    push {lr,r0-r3}
    mov r3,#144
    bl calculateXYLocation
    strb r3,[r2+3328]
    pop {lr,r0-r3}
    mov pc, lr
    
clearSection:               //given x in r0, y in r1, width in r3, height in r4 and colour in r5 paints a section of the screen
    push {lr,r0,r1,r3-r6}
        mov r6,#144
        loopPRow:
        cmp r4,#0
        beq exitcS
        
        bl calculateXYLocation 
        sub r4,r4,#1
        add r1,r1,#1                
        mov r5,r3
        
        loopPColumn:
            
            cmp r5,#0
            beq loopPRow
            
            strb r6,[r2+3328]
            sub r5,r5,#1
            add r2,r2,#1
            bl loopPColumn
        
        exitcS:    
    
    pop {lr,r0,r1,r3-r6}
    mov pc, lr
    
clearInvaders:
        push {lr,r0,r1,r3,r4}

        lsl r3,r6,#1            //acctual width and height  = amount of rows and columns * 2
        lsl r4,r7,#1            //bit shift left to multiplay r6/7 by 2 and storing it into r3/4
           
        mov r0,r9
        mov r1,r10
        bl clearSection
        pop {lr,r0,r1,r3,r4}
        mov pc, lr
    
	
drawShip:			//given a value for x in r0,y in r1, draws the spaceship at that location
	push {lr,r0-r3}
	mov r0,r11
	mov r1,r12
	bl calculateXYLocation	//gets the screen pos in r2
	mov r3,#55
	strb r3,[r2+3328]
	pop {lr,r0-r3}
	mov pc, lr		//Return from a subroutine

moveShip:
    push {lr,r0,r1,r2}
    
    inp r2,4
    cmp r2,#65 // A
    beq moveShipLeft
    
    cmp r2,#68 // D
    beq moveShipRight
	
    moveShipRight:               //r0,r1
        
        mov r0,r11
        mov r1,r12
        
        cmp r11,#31
        beq exitMS
        
        bl clearPixel
        add r11,r11,#1
        mov r0,r11
        bl drawShip
        
        bl exitMS
        
    moveShipLeft:               //r0,r1
        mov r0,r11
        mov r1,r12
        
        cmp r11,#0
        beq exitMS
        bl clearPixel
        
        sub r11,r11,#1
        mov r0,r11
        bl drawShip
        
    exitMS:
        pop {lr,r0,r1,r2}
        mov pc, lr
    
moveInvaders:
    push {lr,r0-r5,r11}
    bl clearInvaders
    mov r11,#32
    lsl r5,r6,#1
    sub r5,r11,r5
        
    cmp r9,r5  // am at the edge?
    bne checkL       // if not nevermind
    cmp r8,#1   // am I also moving right?
    beq downAndLeft    // if so, move down and change direction to left
    
    checkL: 
    
    cmp r9,#1  // am at the left edge?
    bne move       // if not nevermind
    cmp r8,#0   // am I also moving left?
    beq downAndRight    // if so, move down and change direction to right


    move:
    
    // are we going left or right?
    cmp r8,#0
    beq left
    bgt right
    
    left:        
        sub r9,r9,#1
        bl drawInvaderGrid
        bl exitMSI
    
    right:
        add r9,r9,#1
        bl drawInvaderGrid
        bl exitMSI
    
    downAndLeft: 
        add r10,r10,#1
        bl drawInvaderGrid
        mov r8,#0   // change to left
        bl exitMSI
        
    downAndRight:
        add r10,r10,#1
        bl drawInvaderGrid
        mov r8,#1   // change to right
        bl exitMSI
   
    exitMSI:
        pop {lr,r0-r5,r11}
        mov pc, lr
    
halt
halt
halt
halt





