defineRegisters:	

    	mov r4,#33          //laser x and y
    	mov r5,#20
	mov r6,#4          //Space invader cols
	mov r7,#3           //Space invader rows
	mov r8,#2           //space invader direction (0 for left, 1 for right, 2 for still)
	mov r9,#1           //space invader x and y
	mov r10,#3       
	mov r11,#1          // r11 and r12 storing x and y coordinates of spaceship
	mov r12,#20
	

main:
	bl moveShip

    	bl handleLasers
    	bl main
	halt
	
	
drawInvaderGrid:                   //give x in r9, y in r10, cols in r3, rows in r4 draws a grid with a space of one
    push {lr,r0-r5,r11}                 //when y > 0, grid ok but else grid is broken.  x + col shouldnt >= 17 or bad
    
    // get properties of invaders
    mov r0,r9
    mov r1,r10
    mov r3,r6
    mov r4,r7
    // including cols, rows
       
    loopRow:
        cmp r4,#0
        beq exit
        
        bl calculateXYLocation 
        sub r4,r4,#1
        add r1,r1,#2
                
        mov r5,r3
        loopColumn:
            
            cmp r5,#0
            beq loopRow
            strb r11,[r2+3328]
            sub r5,r5,#1
            add r2,r2,#2
            bl loopColumn
        
        exit:
        pop {lr,r0-r5,r11}
        mov pc, lr
	

    

calculateXYLocation:		//given a value for x in r0, y in r1, returns screen position in r2
	push {lr,r0-r1}		//restore all value EXCEPT THE RETURN VALUE
	mov r2,#0
    loopY:				//calculating y
	    add r2,r2,#32
	    sub r1,r1,#1
	    cmp r1,#0
	    bgt loopY
	    add r2,r2,r0		//calculating left
	    pop {lr,r0-r1}
	    mov pc, lr		//return from a subroutine


	
clearPixel:            //given value for x in r0, y in r1, colours in that square white(background colour) in main memory (#144)
    push {lr,r0-r3}
    mov r3,#144
    bl calculateXYLocation
    strb r3,[r2+3328]
    pop {lr,r0-r3}
    mov pc, lr
    

    
clearInvaders:
        push {lr,r11}
        mov r11,#144
        bl drawInvaderGrid
        pop {lr,r11}
        mov pc, lr


moveShip:
    push {lr,r0,r1,r2,r3}
    ldr r3,shipDirection
    mov r0,r11
    mov r1,r12
    bl clearPixel
    
    inp r2,4
    cmp r2,#65 // A
    bne checkForD
    mov r3,#0
    str r3,shipDirection

    checkForD:
    cmp r2,#68 // D
    bne checkStill
    mov r3,#1
    str r3,shipDirection


	checkStill:
	cmp r2,#83 //SS 
	bne checkDirection
	mov r3,#2
	str r3,shipDirection

	b checkDirection	//skiping over data definition
    
    shipDirection:
	.word 1
       
    checkDirection:
        
        cmp r3,#0
        beq moveShipLeft
        
        cmp r3,#1
        beq moveShipRight
	
	cmp r3,#2
	beq exitMS
	
    moveShipRight:               
        cmp r11,#31
        beq exitMS
        
        add r11,r11,#1

        bl exitMS
        
    moveShipLeft:               
        cmp r11,#0
        beq exitMS
        
        sub r11,r11,#1
	
        
    exitMS:
	    mov r0,r11
	    mov r1,r12
	    bl calculateXYLocation	//gets the screen pos in r2
	    mov r3,#55
	    strb r3,[r2+3328]
        pop {lr,r0,r1,r2,r3}
        mov pc,lr
    
moveInvaders:
    	push {lr,r0-r5,r11,r12}
    	bl clearInvaders
	mov r12,#32
    	lsl r5,r6,#1
    	sub r5,r12,r5
        
    	cmp r9,r5  		// am at the edge?
    	bne checkL       	// if not nevermind
    	cmp r8,#1   	// am I also moving right?
    	beq downAndLeft    	// if so, move down and change direction to left
    
    	checkL: 
    
    	cmp r9,#1  // am at the left edge?
    	bne move       // if not nevermind
    	cmp r8,#0   // am I also moving left?
    	beq downAndRight    // if so, move down and change direction to right


    	move:  
    		// are we going left or right?
    		mov r11,#55
    		cmp r8,#0
    		beq left
    		bgt right
    
    	left:        
        	sub r9,r9,#1
        	bl exitMSI
    
    	right:
       		add r9,r9,#1
        	bl exitMSI
    
    	downAndLeft: 
        	add r10,r10,#1
        	mov r8,#0   // change to left
        	bl exitMSI
        
    	downAndRight:
     	   	add r10,r10,#1
      	  	mov r8,#1   // change to right
      	  	bl exitMSI
   
    	exitMSI:
    	    	bl drawInvaderGrid
      		pop {lr,r0-r5,r11,r12}
      	  	mov pc, lr

    
handleLasers:                   //r4 = laser x, r5 = laser y
    push {lr,r0-r3}
    
    cmp r5,#0           	//if r5 != 0 then go to check shoot
    bne checkShoot
        mov r0,r4
        mov r1,r5
        bl clearPixel
    mov r4,#33			//if it r5 = 0 then change the location of the laser to above
    mov r5,#20
     
    checkShoot:
        cmp r4,#33		//if r4 is 33 then it does nothing and waits for the user to press space
        bne moveLaser		//if it isnt 33 then laser will continue moving (go to movelaser)
            
        inp r0,4		//if space was the last key pressed the laser will keep shooting after it gets to the top, eg press D then SPACE laser will shoot from ship after reaching the top
        cmp r0,#32 // SPACE is 32
        // if space has been pressed, shoot a laser
	
        bne moveLaser
        mov r4,r11
        
    
    moveLaser:			
        cmp r4,#33
        beq noLaser
        mov r0,r4
        mov r1,r5
        bl clearPixel
        sub r5,r5,#1   
        
        // drawLaser
	    mov r0,r4
	    mov r1,r5
	    bl calculateXYLocation	//gets the screen pos in r2
	    mov r3,#60
	    strb r3,[r2+3328]	
                     
        
    noLaser:    
    	pop {lr,r0-r3}
    	mov pc, lr

halt

//paintScreen:			//changes all squares to the colour defined in r0
	//push {lr,r1}
				        //colour in all the squares white by starting at square 0, and increasing the counter by one each time the loop finishes.
	//mov r1,#767
	//mov r0,#144
   // loopPaint:
	    //strb r0,[r1+3328]
	    //sub r1,r1,#1
	    //cmp r1,#0
	    //bgt loopPaint	
	    //strb r0,[r1+3328]
	    //pop {lr,r1}
	    //mov pc, lr



